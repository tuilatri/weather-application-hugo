[
{
	"uri": "//localhost:61083/",
	"title": "Weather Application Project",
	"tags": [],
	"description": "",
	"content": "Building an Interactive Weather Application Overview In this workshop, you will be guided step-by-step to build a complete and highly interactive weather application. The project uses JavaScript for the frontend to handle the user interface and interactions, along with a simple Node.js (Express) backend to securely communicate with an external weather API.\nContent Introduction and Architectural Overview Environment Setup Prerequisites Building the Backend with Node.js and Express Building the Frontend - UI and Basic Display Implementing Key Features Polishing the UI and Animations Summary and Further Steps Key Project Features ‚ÑπÔ∏è This application not only displays basic weather information but also integrates many advanced features to provide the best user experience.\nüí° Highlight Features:\nDetailed Weather Display: Provides current weather information and a forecast for the next 7 days. Smart Search: Automatically suggests locations as the user types. Geolocation: Automatically fetches weather data based on the user\u0026rsquo;s current location. Multi-language Support: Supports over 40 different languages, allowing users to choose their preferred display language. Save Favorite Locations: Uses localStorage to save locations that the user is interested in. Unit Conversion: Easily switch the temperature between Celsius (¬∞C) and Fahrenheit (¬∞F). Advanced Metrics: Displays important indices such as Air Quality (AQI), UV index, and chance of rain. Dynamic UI: Features randomly changing backgrounds and applies smooth transition effects. Architecture and Scope ‚ÑπÔ∏è The project is divided into two main parts: the Frontend (client-side) and the Backend (server-side), which communicate with each other via an API.\nFrontend (Client-side)\nResponsible for displaying the entire user interface and handling interactions. main.js: The central file, managing the main flow and events (search, language selection, saving locations). ui.js: Manages updating and displaying data on the DOM (Document Object Model), including the loading skeleton effect. api.js: Sends fetch requests to the backend to get weather data and search suggestions. lang.js: Contains translation data and the logic to update static text according to the selected language. favorites.js: Provides functions to manage the list of favorite locations in localStorage. clock.js: Logic for both the analog and digital clocks displayed on the interface. animations.js: Contains functions for creating effects (e.g., the number counting animation for the temperature). üîí Backend (Server-side)\nActs as a secure proxy layer between the frontend and the WeatherAPI. server.js: Built with Node.js and Express, it creates endpoints for the frontend to call. /weather: Receives requests from the frontend, then calls the WeatherAPI with the API key secured on the server to fetch weather data. /search: Receives search requests, then calls the WeatherAPI to get a list of suggestions. üí° Let\u0026rsquo;s start building this exciting project in the upcoming sections!\n"
},
{
	"uri": "//localhost:61083/3-accessibilitytoinstances/3.1-public-instance/",
	"title": "Connecting to the Server",
	"tags": [],
	"description": "",
	"content": "Detailed Guide for MobaXterm Commands In this section, you will execute commands to connect from your local machine to the Bastion Host, and then from the Bastion Host to the Backend server to install and run the application.\nNote: The commands should be executed sequentially. Ensure you have successfully connected in the previous step before proceeding to the next one.\n1. Connect to the Bastion Host This is the first step, connecting from your computer to the Bastion Host in the Public Subnet.\nOpen MobaXterm and create a new SSH session. Remote host: Enter the Public IPv4 address of project-bastion-host-ec2. Specify username: ec2-user. Use private key: Select the project-keypair.pem file you downloaded when creating the EC2 instance. Setting up an SSH session in MobaXterm 2. Jump to the Backend Instance Now that you are inside the Bastion Host, we need to prepare to connect to the Backend server.\nStep 1: Recreate the key pair file on the Bastion Host. Open a text editor like nano and paste the content of the .pem file from your local machine.\nnano project-keypair.pem Pasting the key content into nano Step 2: Set the correct permissions for the key file. SSH requires the key file to be protected; otherwise, it will refuse the connection.\nchmod 400 project-keypair.pem Setting permissions for the key file Step 3: SSH into the Backend. Use the Private IPv4 address of project-backend-ec2.\nssh -i project-keypair.pem ec2-user@\u0026lt;Private_IP_of_Backend_EC2\u0026gt; Successfully connected to the Backend server 3. Set up the Environment and Application on the Backend Once inside the Backend server, install the necessary tools.\nUpdate the system:\nsudo yum update -y Updating system packages Install Git:\nsudo yum install -y git Installing Git Clone the project source code from GitHub:\ngit clone https://github.com/tuilatri/weather-application.git Cloning the project Navigate into the backend directory:\ncd weather-application/backend Changing to the backend directory Install Node.js:\nsudo dnf install -y nodejs Installing Node.js Install project dependencies:\nnpm install Installing npm packages Configure environment variables:\nnano .env Configuring the .env file 4. Start and Test the Backend Start the application:\nnpm run start Backend application is running Test the application directly on the server: Open another terminal window in MobaXterm, connect again, and then use the curl command to test.\ncurl http://localhost:3000/ Testing the backend with curl 5. Update the Frontend with the Backend\u0026rsquo;s CloudFront Address After the Backend is operational, you need to get the Backend\u0026rsquo;s CloudFront URL and update it in the Frontend\u0026rsquo;s configuration file on S3.\nStep 1: Get the Backend\u0026rsquo;s CloudFront Distribution Domain Name. Go to the CloudFront service in the AWS Console, find and copy the Domain Name of the distribution pointing to the backend.\nStep 2: Access the S3 bucket containing the Frontend source code. Go to the S3 service and select the bucket that holds the frontend source code.\nStep 3: Open and edit the api.js file. Find the api.js file (usually in a js folder or similar), select the file, and click Edit.\nStep 4: Update the API address. In the file\u0026rsquo;s content, find the line declaring the API variable and paste the Backend\u0026rsquo;s CloudFront URL. Then click Save changes.\n// Change the value of this variable const API_URL = \u0026#39;https://your-cloudfront-backend-domain.cloudfront.net\u0026#39;; Pasting the CloudFront URL and saving Step 5: Wait for the Frontend\u0026rsquo;s CloudFront to update. After you save the api.js file, the CloudFront serving the Frontend will need a few minutes to clear the old cache and update to the new version of the file. Please wait about 5-10 minutes before checking the website again. Waiting for CloudFront to update 6. Troubleshooting Guide If you update the code on GitHub but the changes do not appear on the web, follow these steps on the Backend server:\nPull the latest code:\ngit pull origin main Find the running Node.js process:\nps aux | grep node Stop the old process using its PID:\nkill -9 \u0026lt;PID\u0026gt; Real-world example:\n[ec2-user@ip-10-0-144-101 backend]$ ps aux | grep node\rec2-user 3117 0.0 6.6 1127836 64896 pts/1 Sl+ 10:15 0:00 node server.js\r[ec2-user@ip-10-0-144-101 backend]$ kill -9 3117 Restart the application:\nnpm run start "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.1-createvpc/",
	"title": "Create VPC",
	"tags": [],
	"description": "",
	"content": "Create Amazon Virtual Private Cloud (VPC) ‚ÑπÔ∏è Objective\nCreate a separate virtual private cloud (VPC) in AWS for the project. Automatically set up the necessary network components, including Subnets, an Internet Gateway, NAT Gateways, and Route Tables. üîí Execution Steps\n1. Access the VPC service From the AWS Management Console, search for the VPC service. Select VPC from the search results to access the VPC management dashboard. VPC management dashboard 2. Start creating the VPC In the VPC Dashboard, click the Create VPC button. Click the Create VPC button 3. Configure VPC settings On the Create VPC page, in the Resources to create section, select VPC and more to use the automatic creation wizard.\nDetailed configuration:\nName tag auto-generation: project-vpc IPv4 CIDR block: Leave the default 10.0.0.0/16. Number of Availability Zones (AZs): 2 Number of Public subnets: 2 Number of Private subnets: 2 NAT gateways: 1 per AZ (Or select In 1 AZ if you want to save costs) VPC endpoints: None Configure VPC and more Note: Creating NAT Gateways will incur costs. Please delete the resources after completing the workshop to avoid unwanted charges.\n4. Confirm and create VPC After filling in all the information, click Create VPC at the bottom right corner to start the creation process. Finalize and create VPC 5. Check VPC status The resource creation process may take a few minutes. Upon completion, you will see a success notification screen. Click View VPC to review the created resources. VPC creation successful message You will be redirected to the VPC list page, where the newly created project-vpc will have a status of Available. Checking the VPC in the list "
},
{
	"uri": "//localhost:61083/1-introduce/",
	"title": "Introduction and Architecture Overview",
	"tags": [],
	"description": "",
	"content": "Architecture Overview In this workshop, we will deploy a complete weather forecast application onto the AWS environment. The architecture is designed to ensure High Availability, Scalability, and Security by using core AWS services.\nBelow is the overall architecture diagram of the project we will be building:\nAWS Services Used Here is a list of the main services and their roles in this project:\nNetworking and Security Amazon VPC (Virtual Private Cloud): This is the networking foundation for the entire project. We use a VPC to create a separate and isolated network environment on AWS, allowing us to have complete control over network resources, including IP address ranges, subnets, and route tables.\nPublic \u0026amp; Private Subnets:\nPublic Subnets: Used for resources that need direct access from the Internet, such as the Application Load Balancer and the Bastion Host. Private Subnets: Used to host sensitive resources like the backend EC2 instances, preventing direct access from the Internet to enhance security. Security Groups: They act as a virtual firewall for EC2 instances to control inbound and outbound traffic. In this project, we configure separate Security Groups for the Bastion Host, the Backend servers, and the Application Load Balancer to only allow necessary connections.\nCompute and Scaling Amazon EC2 (Elastic Compute Cloud): Provides virtual servers to run the application.\nBackend Instances: EC2 instances located in the private subnet, responsible for running the Node.js application to handle logic and communicate with the weather API. Bastion Host: An EC2 instance placed in the public subnet, acting as a secure access gateway for administrators to SSH into and manage the backend servers in the private subnet. Application Load Balancer (ALB): Automatically distributes incoming traffic from users to multiple backend EC2 instances. The ALB helps increase the application\u0026rsquo;s availability and fault tolerance. It also performs health checks to ensure requests are only sent to healthy servers.\nAuto Scaling Group (ASG): Automatically adjusts the number of backend EC2 instances based on the actual load. When traffic increases, the ASG automatically adds new servers and removes them when traffic decreases, helping to optimize costs and ensure performance.\nStorage and Content Delivery Amazon S3 (Simple Storage Service): A highly scalable object storage service. We use S3 to store the entire frontend source code (HTML, CSS, JavaScript) and configure it to function as a static website.\nAmazon CloudFront: A content delivery network (CDN) service that helps accelerate the loading of web pages and APIs for users worldwide.\nFrontend Distribution: Distributes static content from S3, caching it at Edge Locations closest to the users, while also securing the S3 bucket using Origin Access Identity (OAI). Backend Distribution: Provides a secure HTTPS endpoint for the API, forwarding requests to the Application Load Balancer. "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.2-modifysubnet/",
	"title": "Edit Subnets",
	"tags": [],
	"description": "",
	"content": "Configure Auto-assign Public IP for Public Subnets ‚ÑπÔ∏è Objective\nEnable the feature to automatically assign public IP addresses to resources (like EC2 instances) launched in the Public Subnets. This is necessary to be able to access the Bastion Host from the Internet. üîí Execution Steps\n1. Access the Subnet management page From the VPC Dashboard, select Subnets from the left menu to view the list of created subnets. List of Subnets 2. Configure the first Public Subnet Identify and select one of the two created Public Subnets (e.g., project-vpc-public-subnet-ap-southeast-1a). Click the Actions button and select Edit subnet settings. Select Edit subnet settings 3. Enable the Auto-assign IP feature On the Edit subnet settings page, find the Auto-assign IP settings section. Check the box for Enable auto-assign public IPv4 address. Scroll down and click Save to save the changes. Enabling the Auto-assign Public IP feature 4. Repeat for the remaining Public Subnet Repeat steps 2 and 3 for the second Public Subnet (e.g., project-vpc-public-subnet-ap-southeast-1b) to ensure that instances in both Availability Zones can receive a public IP when needed. Complete the configuration for both Public Subnets "
},
{
	"uri": "//localhost:61083/2-prerequiste/",
	"title": "Preparation Steps",
	"tags": [],
	"description": "",
	"content": "This page provides an overview of the necessary steps to deploy the weather application project onto the AWS environment. Each section in the list below will lead you to a detailed instruction page.\nPlease follow the steps sequentially to ensure the infrastructure is set up correctly.\nMain Workshop Content Configure the Network Environment (VPC)\nCreate VPC Edit Public Subnets Set up Security Layers (Security Group)\nCreate Security Groups for Components Initialize Virtual Servers (EC2)\nCreate EC2 Instances for Bastion Host and Backend Prepare for Scaling (AMI \u0026amp; Launch Template)\nCreate Amazon Machine Image (AMI) Create Launch Template for Auto Scaling Set up Load Balancing (Load Balancer \u0026amp; Target Group)\nCreate Target Group Create Application Load Balancer (ALB) Configure Auto Scaling (Auto Scaling Group)\nCreate Auto Scaling Group Store Frontend on S3\nCreate S3 Bucket and Configure Static Website Hosting Accelerate and Distribute Content (CloudFront)\nCreate CloudFront for Backend (ALB) Create CloudFront for Frontend (S3) "
},
{
	"uri": "//localhost:61083/3-accessibilitytoinstances/",
	"title": "Connecting to the EC2 Instance",
	"tags": [],
	"description": "",
	"content": "After building the entire infrastructure on AWS, the next step is to connect to the virtual servers (EC2 instances) to deploy the backend application\u0026rsquo;s source code.\nDue to our architecture having Public and Private Subnets, we cannot connect directly to the Backend server from the Internet. Instead, we will follow a secure connection process:\nConnect from your personal computer to the Bastion Host (located in the Public Subnet). From the Bastion Host, continue to connect to the Backend Instance (located in the Private Subnet). In this chapter, MobaXterm will be used as the SSH client on Windows to perform the connections. You can also use other tools such as Terminal (macOS/Linux), PuTTY, or Windows Terminal.\n"
},
{
	"uri": "//localhost:61083/2-prerequiste/2.3-createsg/",
	"title": "Create Security Groups for Components",
	"tags": [],
	"description": "",
	"content": "Create Security Groups in Amazon VPC ‚ÑπÔ∏è Objective\nA Security Group acts as a virtual firewall at the instance level to control inbound and outbound traffic. In this section, we will create 3 separate Security Groups for each component in our architecture: Bastion Host: Allows secure SSH access from the outside. Backend: Receives traffic from the Load Balancer and allows administration from the Bastion Host. Application Load Balancer (ALB): Receives public traffic from users. üîí Execution Steps\n1. Create Security Group for the Bastion Host (project-bastion-host-sg) This is the protection layer for the Bastion Host, allowing us to connect to it securely from the Internet.\nStep 1: Start Creating the Security Group\nFrom the VPC Dashboard, select Security Groups from the left menu. Click on Create security group. Create a new Security Group Step 2: Configure Basic Information\nSecurity group name: project-bastion-host-sg Description: Allow access to Bastion Host VPC: Select the project-vpc created in the previous step. Basic information for the Bastion Host SG Step 3: Set up Inbound Rules\nClick Add rule and configure the following rules: Type Protocol Port range Source Description SSH TCP 22 My IP Allows you to connect via SSH from your current IP. HTTP TCP 80 Anywhere-IPv4 Allows HTTP access from anywhere. HTTPS TCP 443 Anywhere-IPv4 Allows HTTPS access from anywhere. All ICMP-IPv4 All All Anywhere-IPv4 Allows ping to check connectivity. Configuring Inbound Rules for the Bastion Host SG Step 4: Scroll down and click Create security group. 2. Create Security Group for the Backend (project-backend-sg) This protection layer only allows access from the Application Load Balancer and the Bastion Host, ensuring the backend servers are not directly accessible from the Internet.\nStep 1: Configure Basic Information\nClick Create security group again. Security group name: project-backend-sg Description: Allow access from ALB and Bastion Host VPC: Select the project-vpc. Basic information for the Backend SG Step 2: Set up Inbound Rules\nClick Add rule and configure the following rules: Type Protocol Port range Source Description Custom TCP TCP 3000 Custom -\u0026gt; project-alb-sg Allows the ALB to send traffic to the backend application. SSH TCP 22 Custom -\u0026gt; project-bastion-host-sg Allows SSH connection from the Bastion Host for administration. All ICMP-IPv4 All All Anywhere-IPv4 Allows ping to check connectivity. When selecting the Source, type sg- into the search box, and AWS will display a list of available Security Groups for you to choose from.\nConfiguring Inbound Rules for the Backend SG Step 3: Click Create security group. 3. Create Security Group for the Application Load Balancer (project-alb-sg) This protection layer allows users from the Internet to access our application through the ALB.\nStep 1: Configure Basic Information\nClick Create security group. Security group name: project-alb-sg Description: Allow public traffic to ALB VPC: Select the project-vpc. Basic information for the ALB SG Step 2: Set up Inbound Rules\nClick Add rule and configure the following rules: Type Protocol Port range Source Description HTTP TCP 80 Anywhere-IPv4 Allows users to access via HTTP. HTTPS TCP 443 Anywhere-IPv4 Allows users to access via HTTPS. Configuring Inbound Rules for the ALB SG Step 3: Set up Outbound Rules The ALB needs to send traffic to the backend on port 3000. By default, Outbound Rules allow all traffic out, but for better security, we should restrict this. Select the Outbound rules tab -\u0026gt; Edit outbound rules. Delete the default rule and Add rule with the following: Type Protocol Port range Destination Description Custom TCP TCP 3000 Custom -\u0026gt; project-backend-sg Allows the ALB to send traffic to the backend servers. Configuring Outbound Rules for the ALB SG Step 4: Click Save rules, then click Create security group. After completion, you will have 3 Security Groups ready to be assigned to their corresponding resources.\n"
},
{
	"uri": "//localhost:61083/4-cleanup/",
	"title": "Cleaning Up Resources",
	"tags": [],
	"description": "",
	"content": "\rEXTREMELY IMPORTANT: This is a mandatory step after you complete the workshop. Failing to clean up resources will cause your AWS account to continue incurring costs, especially for services like NAT Gateway, Application Load Balancer, and EC2.\nTo ensure nothing is missed, we must delete the resources in the reverse order of their creation.\nüîí Execution Steps\n1. Delete CloudFront Distributions You need to delete both distributions created for the Frontend (S3) and Backend (ALB).\nNavigate to the CloudFront service. Select a distribution, click Disable, and confirm. After the distribution is disabled, select it again and click Delete. Repeat the process for the remaining distribution. 2. Delete the Auto Scaling Group This action will also automatically terminate the EC2 instances managed by the ASG.\nNavigate to the EC2 service -\u0026gt; Auto Scaling Groups. Select project-backend-asg and click Delete. Type delete to confirm and complete the action. 3. Delete the Application Load Balancer Navigate to EC2 -\u0026gt; Load Balancers. Select project-backend-alb, go to Actions, and choose Delete load balancer. Type confirm to confirm. 4. Delete the Target Group Navigate to EC2 -\u0026gt; Target Groups. Select project-backend-target-group, go to Actions, and choose Delete. 5. Terminate Remaining EC2 Instances Instances not managed by the ASG must be terminated manually.\nNavigate to EC2 -\u0026gt; Instances. Select the project-bastion-host-ec2 and project-backend-ec2 instances (if the latter wasn\u0026rsquo;t already terminated by the ASG). Select Instance state -\u0026gt; Terminate instance. 6. Delete the Launch Template Navigate to EC2 -\u0026gt; Launch Templates. Select project-backend-lauch-template, go to Actions, and choose Delete template. 7. Delete the AMI and Related Snapshot Step 1: Deregister the AMI Navigate to EC2 -\u0026gt; AMIs. Select project-backend-ec2-ami, go to Actions, and choose Deregister AMI. Step 2: Delete the Snapshot Navigate to EC2 -\u0026gt; Snapshots. Find the Snapshot created by the AMI (the description usually contains the AMI ID), select it, and go to Actions -\u0026gt; Delete snapshot. 8. Delete the S3 Bucket You must first delete all objects inside the bucket.\nNavigate to the S3 service. Go into the project-frontend-030925 bucket. Select all files and click Delete. Once the bucket is empty, go back, select the bucket, and click Delete. 9. Delete the VPC This is the final step, which will delete the VPC and its associated resources like Subnets, Route Tables, Internet Gateway, and most importantly, the NAT Gateway.\nNavigate to the VPC service. Select Your VPCs, and choose project-vpc. Click Actions -\u0026gt; Delete VPC. A window will appear listing the resources to be deleted. Type delete and confirm. 10. Delete the Key Pair Navigate to EC2 -\u0026gt; Key Pairs. Select project-keypair, go to Actions, and choose Delete. "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.4-createec2/",
	"title": "Create EC2 Instances for Bastion Host and Backend",
	"tags": [],
	"description": "",
	"content": "Initialize EC2 Instances ‚ÑπÔ∏è Objective\nInitialize two separate virtual servers (EC2 Instances): Bastion Host: Placed in the Public Subnet to act as a \u0026ldquo;jump box,\u0026rdquo; helping us securely connect to resources in the Private Subnet. Backend Instance: Placed in the Private Subnet to run the application, protected from direct access from the Internet. üîí Execution Steps\nFirst, we will initialize the EC2 Instance for the Bastion Host.\n1. Create EC2 Instance for Bastion Host (project-bastion-host-ec2) Step 1: Start Launching the Instance\nIn the AWS Management Console, find and select the EC2 service. From the EC2 Dashboard, click on Launch instance. Start Launching Instance Step 2: Set Name and Choose AMI\nName: project-bastion-host-ec2 Application and OS Images (Amazon Machine Image): Select Amazon Linux. Setting the name and choosing the Amazon Machine Image Step 3: Choose Instance Type\nInstance type: Select t2.micro (part of the Free Tier). Step 4: Create a Key Pair for Access\nThis is a crucial step to be able to SSH into the instance. Click on Create new key pair. Key pair name: project-keypair Key pair type: RSA Private key file format: .pem Click Create key pair, and the browser will automatically download the .pem file. **IMPORTANT:** Store this `.pem` file in a safe place. You will not be able to download it a second time. If you lose it, you will lose access to your EC2 instance.\rCreating a new Key Pair Step 5: Configure Network Settings\nClick on Edit in the Network settings section. VPC: Select the project-vpc you created. Subnet: Select one of the two Public Subnets (e.g., ...public-subnet-ap-southeast-1a). Auto-assign public IP: Enable. Firewall (security groups): Select Select existing security group and choose project-bastion-host-sg. Configuring network settings for the Bastion Host Step 6: Launch the Instance\nReview the information in the Summary panel. Click Launch instance. 2. Create EC2 Instance for Backend (project-backend-ec2) Next, we will repeat the process to create the Backend instance, with a few important changes in the Network Settings.\nStep 1: Start Launching the Instance\nFrom the EC2 Dashboard, click Launch instance again. Step 2: Set Name and Choose AMI\nName: project-backend-ec2 AMI: Select Amazon Linux. Step 3: Choose Instance Type\nInstance type: Select t2.micro. Step 4: Select the Existing Key Pair\nIn the Key pair (login) section, select the project-keypair created earlier. Selecting the existing Key Pair Step 5: Configure Network Settings\nClick on Edit in the Network settings section. VPC: Select project-vpc. Subnet: Select one of the two Private Subnets (e.g., ...private-subnet-ap-southeast-1b). Auto-assign public IP: Disable. This is a key difference to protect the backend server. Firewall (security groups): Select Select existing security group and choose project-backend-sg. Configuring network settings for the Backend Instance Step 6: Launch the Instance\nReview the information and click Launch instance. After completing, you can click View all instances to see both newly created servers in the Running state.\nList of created EC2 Instances "
},
{
	"uri": "//localhost:61083/5-conclusion/",
	"title": "Conclusion and Next Steps",
	"tags": [],
	"description": "",
	"content": "Congratulations on completing the workshop!\nYou have successfully built a modern, scalable, and highly available web application architecture on the AWS platform. This is not just a simple exercise but a solid foundation that simulates how real-world systems are constructed in the cloud.\nInstead of just looking back at what has been done, let\u0026rsquo;s explore how to make this system even better, more automated, and more robust.\nUpgrading and Extending the Project The current architecture is an excellent starting point. Below are potential improvement paths you can explore to enhance your skills:\n1. Automate Deployment with a CI/CD Pipeline Problem: Currently, the code update process is manual (SSH into the server, git pull, npm restart). This process is time-consuming, prone to errors, and unsuitable for a professional environment. Solution: Build a CI/CD (Continuous Integration/Continuous Deployment) pipeline using services like AWS CodePipeline, AWS CodeBuild, and AWS CodeDeploy. With CI/CD, every time you push new code to GitHub, the system will automatically build, test, and deploy the new version to the EC2 instances without any manual intervention. 2. Manage Infrastructure with Code (Infrastructure as Code - IaC) Problem: Setting up the entire infrastructure manually via the AWS Console (ClickOps) is difficult to reproduce accurately and lacks version control capabilities. Solution: Learn to use IaC tools like AWS CloudFormation or Terraform. You can define the entire architecture (VPC, EC2, ALB, S3, etc.) in code files. This allows you to create, update, or delete the entire environment with just a few commands, ensuring consistency and automation. 3. Integrate a Managed Database Problem: Our application currently lacks a database for persistent data storage. Solution: Instead of manually installing a database on an EC2 instance (which requires significant administrative effort), use AWS\u0026rsquo;s managed database services. Amazon RDS (Relational Database Service): For relational databases like MySQL, PostgreSQL. Amazon DynamoDB: For NoSQL databases, suitable for applications requiring high performance and low latency. 4. Use a Custom Domain with Amazon Route 53 Problem: Users are accessing the application through the default, long, and hard-to-remember CloudFront domain names. Solution: Use Amazon Route 53, AWS\u0026rsquo;s DNS service, to register a custom domain (e.g., my-weather-app.com) and point it to your CloudFront distributions. 5. Monitoring, Logging, and Alerting with Amazon CloudWatch Problem: How do you know if the application is running smoothly or encountering errors? When should Auto Scaling be triggered? Solution: Integrate more deeply with Amazon CloudWatch. You can: CloudWatch Logs: Collect logs from your applications on EC2 for debugging. CloudWatch Metrics: Monitor key performance indicators like CPU Utilization and Request Count. CloudWatch Alarms: Set up automated alerts that send you emails or messages when an issue occurs (e.g., high CPU, website is down). 6. Enhance Security with AWS WAF Problem: The application could be vulnerable to common web attacks such as SQL injection or cross-site scripting (XSS). Solution: Integrate AWS WAF (Web Application Firewall) with your CloudFront distribution or Application Load Balancer. WAF helps protect your application by filtering and blocking malicious traffic. Your journey with AWS has just begun. With the solid foundation from this workshop, you are now ready to explore and conquer more complex services and challenges.\nHappy building!\n"
},
{
	"uri": "//localhost:61083/2-prerequiste/2.5-createami/",
	"title": "Create Amazon Machine Image (AMI)",
	"tags": [],
	"description": "",
	"content": "Create an AMI from the Backend Instance ‚ÑπÔ∏è Objective\nAn Amazon Machine Image (AMI) is a complete \u0026ldquo;snapshot\u0026rdquo; or backup of an EC2 instance, including the operating system, configuration, and data. The main purpose of creating an AMI in this workshop is to have a standard \u0026ldquo;template\u0026rdquo; for the backend server. This template will be used by the Launch Template and Auto Scaling Group to automatically create identical copies of the backend server when scaling is needed. üîí Execution Steps\n1. Select the Source EC2 Instance In the EC2 Dashboard, navigate to Instances. From the list, select the project-backend-ec2 instance. Select the Backend EC2 Instance 2. Start the Image Creation Process After selecting the instance, click on the Actions menu. Select Image and templates. Select Create image. Starting to create an Image from the Actions menu 3. Configure the AMI Information On the Create image page, fill in the following information: Image name: project-backend-ec2-ami Image description: project-backend-ec2-ami Other options can be left at their default values. Filling in the configuration information for the AMI 4. Finalize and Check the Status Scroll down and click Create image.\nYou will receive a notification that the AMI creation process has started.\nTo monitor the progress:\nIn the left menu, under Images, select AMIs. You will see the project-backend-ec2-ami AMI with a pending status. This process may take a few minutes. Wait until the Status changes to Available. Checking the completed AMI status "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.6-createlaunchtemplate/",
	"title": "Create Launch Template for Auto Scaling",
	"tags": [],
	"description": "",
	"content": "Initialize Launch Template ‚ÑπÔ∏è Objective\nA Launch Template acts as a detailed \u0026ldquo;blueprint\u0026rdquo; for launching EC2 instances. It stores all necessary configuration parameters such as the AMI, instance type, key pair, security groups, and network settings. Our goal is to create a Launch Template that uses the backend server\u0026rsquo;s AMI (project-backend-ec2-ami) created in the previous step. The Auto Scaling Group will rely on this blueprint to automatically launch new instances consistently and accurately. üîí Execution Steps\n1. Access Launch Templates From the EC2 Dashboard, in the left menu, scroll down and select Launch Templates. Click on Create launch template. Starting to create a Launch Template 2. Configure Basic Information Launch template name: project-backend-lauch-template Template version description: Template for weather project backend servers Filling in basic information for the Launch Template 3. Select AMI (Amazon Machine Image) In the Application and OS Images (Amazon Machine Image) section, select the My AMIs tab. Select Owned by me, and you will see the AMI created in the previous step. Select project-backend-ec2-ami. Selecting the created AMI 4. Select Instance Type and Key Pair Instance type: Select t2.micro. Key pair (login): Select project-keypair from the dropdown list. Selecting the Instance Type and Key Pair 5. Configure Network Settings In the Network settings section, we will specify the Security Group. Security groups: Select Select existing security group. In the Common security groups list, select project-backend-sg. Configuring the Security Group 6. Finalize and Review the Launch Template Review all the configured information. Scroll down and click Create launch template. After it\u0026rsquo;s created successfully, click View launch templates to see the template you just created in the list. Launch Template created successfully Viewing the Launch Template in the list "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.7-createtargetgroup/",
	"title": "Create Target Group",
	"tags": [],
	"description": "",
	"content": "Initialize Target Group ‚ÑπÔ∏è Objective\nA Target Group is used to group resources (in this case, EC2 instances) to which the Application Load Balancer (ALB) will route traffic. The ALB also uses the Target Group to perform Health Checks, ensuring that it only sends requests to instances that are operating correctly. We will create a Target Group to manage the project\u0026rsquo;s backend servers. üîí Execution Steps\n1. Access Target Groups From the EC2 Dashboard, in the left menu, scroll down to the Load Balancing section and select Target Groups. Click on Create target group. Starting to create a Target Group 2. Choose a target type In the Choose a target type step, select Instances because we want the Load Balancer to route traffic to EC2 instances. Click Next. Choosing Instances as the Target Type 3. Specify group details Target group name: project-backend-target-group Protocol - Port: Select HTTP and enter 3000. This is the port our backend Node.js application is listening on. VPC: Select project-vpc. Health checks: Health check protocol: HTTP Health check path: /health. This is the path the Load Balancer will access to check if the server is healthy (related to the backend code). Filling in the configuration details for the Target Group 4. Register initial targets In this step, we will register the manually created backend instance with the Target Group. In the Available instances table, select project-backend-ec2. Click Include as pending below. This will add the instance to the list of targets to be registered. Registering at least one initial instance helps us verify that the Load Balancer and Target Group are working correctly after configuration. Subsequent instances will be automatically registered by the Auto Scaling Group.\nRegistering an instance with the Target Group 5. Finalize and review Scroll down and click Create target group. After successful creation, you will be taken to the Target Group\u0026rsquo;s details page. Initially, the instance\u0026rsquo;s health status may be unhealthy or initial. Wait a few minutes for the Load Balancer to perform its health check, and the status will change to healthy. Target Group created successfully "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.8-createalb/",
	"title": "Create Application Load Balancer (ALB)",
	"tags": [],
	"description": "",
	"content": "Initialize Application Load Balancer (ALB) ‚ÑπÔ∏è Objective\nThe Application Load Balancer (ALB) acts as the entry point for receiving and distributing user traffic to the backend servers. By placing the ALB in Public Subnets across multiple Availability Zones (AZs), we ensure the application has high availability. If one AZ experiences an issue, the ALB will automatically redirect traffic to the servers in the remaining AZs. The ALB will listen for incoming requests and forward them to the Target Group (project-backend-target-group) that we created in the previous step. üîí Execution Steps\n1. Start Creating the Load Balancer From the EC2 Dashboard, in the left menu, scroll down to the Load Balancing section and select Load Balancers. Click on Create load balancer. Starting to create a Load Balancer 2. Choose the Load Balancer Type There are several types of Load Balancers. Since our application operates at the application layer (HTTP/HTTPS), select Application Load Balancer by clicking Create. Choosing Application Load Balancer 3. Configure Basic Information Load balancer name: project-backend-alb Scheme: Internet-facing (Because this ALB will receive traffic directly from the internet). IP address type: IPv4 Filling in the basic configuration for the ALB 4. Configure Network Mapping This is a crucial step to ensure the ALB is accessible from the internet. VPC: Select project-vpc. Mappings: Select both Availability Zones we are using. For each AZ, choose the corresponding Public Subnet. Selecting the VPC and Public Subnets 5. Configure Security Groups Keep the default Security Group selected. From the dropdown list, select the Security Group created specifically for the ALB: project-alb-sg. Selecting the Security Group for the ALB 6. Configure Listeners and Routing This is where we define how the ALB handles incoming requests. Listener: Keep HTTP and Port 80 as they are. Default action: From the dropdown list, select the project-backend-target-group created in the previous step. This action instructs the ALB to forward all traffic from port 80 to this Target Group. Configuring the Listener and forwarding to the Target Group 7. Finalize, Check Status, and Test Access Review the information in the Summary section and click Create load balancer. After it\u0026rsquo;s created successfully, click View load balancer. Note: The process of provisioning a Load Balancer will take about 5-10 minutes. Its state will change from provisioning to active. Please be patient.\nWaiting for the ALB to become Active Once the ALB is active, select it and copy the DNS name from the Details tab. Copying the ALB\u0026#39;s DNS name You will be able to see the result after you connect to the Backend and deploy the project in a later step. Paste this DNS name into a browser. If everything is configured correctly, you will see the message: Backend is running! Successful test via the ALB\u0026#39;s DNS ```\n"
},
{
	"uri": "//localhost:61083/2-prerequiste/2.9-createasg/",
	"title": "Create Auto Scaling Group",
	"tags": [],
	"description": "",
	"content": "Initialize Auto Scaling Group (ASG) ‚ÑπÔ∏è Objective\nThe Auto Scaling Group (ASG) is the heart of a flexible and scalable architecture on AWS. Its job is to automatically adjust the number of running EC2 instances to meet current traffic demands. When traffic increases, the ASG will automatically add new instances (Scale Out). When traffic decreases, it will automatically remove unnecessary instances (Scale In) to save costs. We will configure an ASG that uses the created Launch Template to know how to create instances, and attach it to the Load Balancer to know when to create them. üîí Execution Steps\n1. Start Creating the Auto Scaling Group From the EC2 Dashboard, in the left menu, scroll to the bottom and select Auto Scaling Groups. Click on Create Auto Scaling group. Starting to create an Auto Scaling Group 2. Set the Name and Choose the Launch Template Auto Scaling group name: project-backend-asg Launch template: Select project-backend-lauch-template from the list. After selecting, click Next. Choosing the name and Launch Template 3. Configure the Network VPC: Select project-vpc. Availability Zones and subnets: Select both Private Subnets we have. The ASG will use these subnets to launch new instances, ensuring they are protected and highly available. Click Next. Configuring the VPC and Private Subnets 4. Integrate with the Load Balancer Select Attach to an existing load balancer. Select Choose from your load balancer target groups. From the dropdown list, select project-backend-target-group. Click Next. Attaching the ASG to the existing Target Group 5. Configure Group Size and Scaling Policies Group size:\nDesired capacity: 1 (The desired number of instances when the ASG is created). Minimum capacity: 1 (The minimum number of instances that must be running). Maximum capacity: 2 (The maximum number of instances allowed). Scaling policies:\nSelect Target tracking scaling policy. Scaling policy name: Target Tracking Policy Metric type: Application Load Balancer request count per target. Target value: 30. (This means: if each instance has to handle an average of more than 30 requests per minute, add a new instance). Click Next.\nConfiguring group size and scaling policies 6. Skip Optional Steps You will be taken to the Add notifications and Add tags pages. We do not need to configure them in this workshop. Click Next on both pages to skip them. 7. Review and Complete Review all the configured information on the Review page. Scroll down and click Create Auto Scaling group. Reviewing and creating the Auto Scaling Group 8. Check the Status After creation, the ASG will appear in the list. Select project-backend-asg and switch to the Instance management tab. You will see the ASG is in the process of launching a new instance to meet the Desired capacity of 1. Wait until the instance\u0026rsquo;s Lifecycle is InService. This indicates the instance is ready and has been registered with the Target Group. Checking the instance managed by the ASG "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.10-createcloudfrontbe/",
	"title": "Create CloudFront for Backend (ALB)",
	"tags": [],
	"description": "",
	"content": "Create a CloudFront Distribution for the Backend ‚ÑπÔ∏è Objective\nAmazon CloudFront is a content delivery network (CDN) service that speeds up the distribution of web content (like APIs, videos, and data) to end-users with low latency and high transfer speeds. In this architecture, CloudFront will serve as the public \u0026ldquo;gateway\u0026rdquo; for our backend API, instead of accessing the ALB directly. Key Benefits: HTTPS Termination: CloudFront will handle the HTTPS connection from the user. It will then communicate with the ALB over HTTP within AWS\u0026rsquo;s internal network. This simplifies SSL/TLS management, as we don\u0026rsquo;t need to configure certificates on the ALB or EC2 instances. Increased Performance and Reduced Latency: CloudFront brings your API closer to users through its global network of edge locations. Enhanced Security: It provides an additional layer of protection, masking the ALB, and can be integrated with AWS WAF (Web Application Firewall). üîí Execution Steps\n1. Start Creating the Distribution From the AWS Management Console, search for and select the CloudFront service. Click on Create a CloudFront distribution. Starting to create a CloudFront Distribution 2. Configure the Origin Origin domain: Click the field and select the DNS name of the Application Load Balancer project-backend-alb from the dropdown list. Protocol: Select HTTP only. HTTP port: Leave the default as 80. Configuring the Origin as the Application Load Balancer 3. Configure Default Cache Behavior This is the most critical configuration part to ensure the API works correctly. Viewer protocol policy: Select Redirect HTTP to HTTPS to automatically redirect users to a secure connection. Allowed HTTP methods: Select GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE to allow all API methods. Cache policy: Select CachingDisabled. This is crucial because we do not want CloudFront to cache API responses (which are dynamic). Origin request policy - optional: Select AllViewer. This policy forwards all information from the user (headers, query strings, cookies) to the ALB, ensuring the backend receives all the necessary data to process the request. Configuring Cache Behavior for the API 4. Configure Other Settings Web Application Firewall (WAF): Select Do not enable security protections for the purpose of this workshop. 5. Finalize and Test Scroll to the bottom of the page and click Create distribution. The process of deploying a new distribution across CloudFront\u0026rsquo;s entire network can take 5 to 15 minutes. You will see the status Deploying. Waiting for CloudFront to complete deployment When the status changes to Enabled (showing the Last modified date), copy the Distribution domain name (e.g., d12345abcdef.cloudfront.net). Copying the Distribution\u0026#39;s Domain Name Paste this domain name into your browser. The returned result should be identical to when you accessed it via the ALB\u0026rsquo;s DNS: Backend is running!. Successful test via CloudFront "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.11-creates3/",
	"title": "Create S3 Bucket and Configure Static Website Hosting",
	"tags": [],
	"description": "",
	"content": "Create S3 Bucket to Store the Frontend ‚ÑπÔ∏è Objective\nAmazon S3 (Simple Storage Service) is a highly scalable, durable, and low-cost object storage service. We will use S3 to store all the static files of the frontend application (HTML, CSS, JavaScript, images). Afterward, we will configure this bucket to act as a static web server (Static Website Hosting), allowing direct access to the website via an S3 URL. üîí Execution Steps\n1. Start Creating the S3 Bucket In the AWS Management Console, search for and select the S3 service. Click on Create bucket. Starting to create an S3 Bucket 2. Configure Basic Information Bucket name: project-frontend-030925 S3 bucket names are globally unique. If this name already exists, you need to add characters or numbers to make it unique (e.g., `project-frontend-030925-yourname`).\rAWS Region: Select the Region you are working in.\nObject Ownership: Select ACLs enabled. We select this option to be able to grant public access to individual files using Access Control Lists (ACL), a necessary method for the next configuration step.\rConfiguring name, Region, and enabling ACLs 3. Configure Public Access Settings Check the box for Block all public access. This step allows us to make objects in the bucket publicly accessible. In the following steps, CloudFront will be configured to protect this bucket more securely.\nEnabling Block Public Access Bucket Versioning: Select Enable. Scroll down and click Create bucket. 4. Upload Frontend Files to the Bucket After successfully creating the bucket, go into the project-frontend-030925 bucket. Click Upload and upload all files and folders of your frontend project. Uploading Frontend files to S3 5. Configure Static Website Hosting In the bucket, switch to the Properties tab. Scroll down to the bottom to the Static website hosting section and click Edit. Select Enable. Index document: index.html Click Save changes. Enabling and configuring Static Website Hosting "
},
{
	"uri": "//localhost:61083/2-prerequiste/2.12-createcloudfrontfe/",
	"title": "Create CloudFront for Frontend (S3)",
	"tags": [],
	"description": "",
	"content": "Initialize CloudFront Distribution for Frontend (S3) ‚ÑπÔ∏è Objective\nCreate a second CloudFront Distribution, this time dedicated to distributing the static frontend files from the S3 bucket. Improve page load speed: CloudFront will cache the frontend files at Edge Locations worldwide, helping users everywhere access the website with the lowest possible latency. Enhance security: We will configure Origin Access Identity (OAI), a special feature of CloudFront. OAI will lock down the S3 bucket, allowing only a single \u0026ldquo;user\u0026rdquo;‚ÄîCloudFront‚Äîto read the files. End-users will no longer be able to access the S3 bucket directly, ensuring all access goes through CloudFront. üîí Execution Steps\n1. Start Creating the Distribution In the AWS Management Console, return to the CloudFront service. Click on Create distribution. Starting to create a new CloudFront Distribution 2. Configure the Origin Origin domain: Click on this field and select your S3 bucket from the list, for example: project-frontend-030925.s3.ap-southeast-1.amazonaws.com. Origin access: This is the most critical security configuration step. Select Legacy access identities. Origin access identity: Click on Create new OAI. Leave the default name and click Create. Bucket policy: Select Yes, update the bucket policy. This action will automatically add a policy to your S3 bucket, granting the newly created OAI permission to read the objects. Configuring the Origin as an S3 Bucket and creating an OAI 3. Configure the Remaining Settings Web Application Firewall (WAF): Select Do not enable security protections. Settings - Default root object: Type index.html. This is a required setting. It tells CloudFront which file to return when a user accesses the root domain (e.g., `https://d...cloudfront.net/`) without specifying a particular file.\rSetting the Default Root Object 4. Finalize and Test Scroll to the bottom and click Create distribution. Similar to before, the deployment process will take a few minutes. Wait until the status is no longer Deploying. Copy the Distribution domain name value. Copying the Domain Name of the Frontend Distribution Paste this domain name into your browser. You should see your frontend application load successfully. "
},
{
	"uri": "//localhost:61083/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:61083/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]